{"ast":null,"code":"import RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nimport CollisionInfo from './CollisionInfo';\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, mass, friction, restitution, gravity) {\n    super(center, mass);\n    this.mass = mass;\n    this.gravity = gravity;\n    this.mType = 'Rectangle';\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n\n    // Create a div element to represent this rectangle\n    this.div = document.createElement('div');\n    this.div.style.position = 'absolute';\n    this.div.className = 'rect-circle';\n    this.div.style.transform = 'scale(0.8)';\n    setTimeout(() => {\n      this.div.style.width = `${width}px`;\n      this.div.style.height = `${height}px`;\n      this.div.style.transform = 'scale(1)';\n    }, 1000);\n    // this.div.textContent = 'mass: ' + this.mass;\n    // this.div.style.backgroundColor = 'rgba(0, 0, 255, 0.5)'; // Semi-transparent blue\n    // this.div.style.border = '1px solid black';\n    document.body.appendChild(this.div);\n  }\n  update() {\n    // Update the position and rotation of the div\n    this.div.style.left = `${this.mCenter.x - this.mWidth / 2}px`;\n    this.div.style.top = `${this.mCenter.y - this.mHeight / 2}px`;\n    this.div.style.transform = `rotate(${this.mAngle}rad)`;\n  }\n  move(v) {\n    super.move(v);\n    this.mVertex = this.mVertex.map(vertex => vertex.add(v));\n    this.update(); // Update div position after moving\n  }\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map(vertex => vertex.rotate(this.mCenter, angle));\n    this.update(); // Update div rotation after rotating\n  }\n  collisionTest(otherShape, collisionInfo) {\n    let status = false;\n    if (otherShape.mType === 'Circle') {\n      status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n      status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n  }\n  findSupportPoint(dir, ptOnEdge) {\n    let tmpSupport = {\n      mSupportPoint: null,\n      mSupportPointDist: -9999999\n    };\n    let vToEdge;\n    let projection;\n    for (let i = 0; i < this.mVertex.length; i++) {\n      vToEdge = this.mVertex[i].subtract(ptOnEdge);\n      projection = vToEdge.dot(dir);\n      if (projection > 0 && projection > tmpSupport.mSupportPointDist) {\n        tmpSupport.mSupportPoint = this.mVertex[i];\n        tmpSupport.mSupportPointDist = projection;\n      }\n    }\n    return tmpSupport;\n  }\n  findAxisLeastPenetration(otherRect, collisionInfo) {\n    let n;\n    let supportPoint = null;\n    let bestDistance = Infinity;\n    let bestIndex = null;\n    let hasSupport = true;\n    let i = 0;\n    while (hasSupport && i < this.mFaceNormal.length) {\n      n = this.mFaceNormal[i];\n      const dir = n.scale(-1);\n      const ptOnEdge = this.mVertex[i];\n      const tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n      hasSupport = tmpSupport && tmpSupport.mSupportPoint !== null;\n      if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n        bestDistance = tmpSupport.mSupportPointDist;\n        bestIndex = i;\n        supportPoint = tmpSupport.mSupportPoint;\n      }\n      i++;\n    }\n    if (hasSupport && bestIndex !== null && supportPoint !== null) {\n      const bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n      collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n    }\n    return hasSupport;\n  }\n  collidedRectRect(r1, r2, collisionInfo) {\n    let status1 = false;\n    let status2 = false;\n    const collisionInfoR1 = new CollisionInfo();\n    const collisionInfoR2 = new CollisionInfo();\n    status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n    if (status1) {\n      status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n      if (status2) {\n        if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n          const depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n          collisionInfo.setInfo(collisionInfoR1.getDepth(), collisionInfoR1.getNormal(), collisionInfoR1.mStart.subtract(depthVec));\n        } else {\n          collisionInfo.setInfo(collisionInfoR2.getDepth(), collisionInfoR2.getNormal().scale(-1), collisionInfoR2.mStart);\n        }\n      }\n    }\n    return status1 && status2;\n  }\n  collidedRectCirc(otherCir, collisionInfo) {\n    let circ2Pos, v, projection, bestDistance, nearestEdge, inside;\n    for (let i = 0; i < 4; ++i) {\n      circ2Pos = otherCir.mCenter;\n      v = circ2Pos.subtract(this.mVertex[i]);\n      projection = v.dot(this.mFaceNormal[i]);\n      if (projection > 0) {\n        bestDistance = projection;\n        nearestEdge = i;\n        inside = false;\n        break;\n      }\n      if (projection > bestDistance) {\n        bestDistance = projection;\n        nearestEdge = i;\n      }\n    }\n    if (!inside) {\n      let v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n      let v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n      let dot = v1.dot(v2);\n      if (dot < 0) {\n        const dis = v1.length();\n        if (dis > otherCir.mRadius) return false;\n        const normal = v1.normalize();\n        const radiusVec = normal.scale(-otherCir.mRadius);\n        collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n      } else {\n        v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n        v2 = v2.scale(-1);\n        dot = v1.dot(v2);\n        if (dot < 0) {\n          const dis = v1.length();\n          if (dis > otherCir.mRadius) return false;\n          const normal = v1.normalize();\n          const radiusVec = normal.scale(-otherCir.mRadius);\n          collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n        } else {\n          if (bestDistance < otherCir.mRadius) {\n            const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n            collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n          } else {\n            return false;\n          }\n        }\n      }\n    } else {\n      const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n      collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n    }\n    return true;\n  }\n}\nexport default Rectangle;","map":{"version":3,"names":["RigidShape","Vec2","CollisionInfo","Rectangle","constructor","center","width","height","mass","friction","restitution","gravity","mType","mWidth","mHeight","mVertex","mBoundRadius","Math","sqrt","x","y","div","document","createElement","style","position","className","transform","setTimeout","body","appendChild","update","left","mCenter","top","mAngle","move","v","map","vertex","add","rotate","angle","collisionTest","otherShape","collisionInfo","status","collidedRectCirc","collidedRectRect","findSupportPoint","dir","ptOnEdge","tmpSupport","mSupportPoint","mSupportPointDist","vToEdge","projection","i","length","subtract","dot","findAxisLeastPenetration","otherRect","n","supportPoint","bestDistance","Infinity","bestIndex","hasSupport","mFaceNormal","scale","bestVec","setInfo","r1","r2","status1","status2","collisionInfoR1","collisionInfoR2","getDepth","depthVec","getNormal","mStart","otherCir","circ2Pos","nearestEdge","inside","v1","v2","dis","mRadius","normal","normalize","radiusVec"],"sources":["/Users/mac/Desktop/apps/physics/physics_engine/React/src/Rectangle.js"],"sourcesContent":["import RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nimport CollisionInfo from './CollisionInfo';\n\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, mass, friction, restitution, gravity) {\n    super(center, mass);\n    this.mass = mass;\n    this.gravity = gravity;\n    this.mType = 'Rectangle';\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n\n    // Create a div element to represent this rectangle\n    this.div = document.createElement('div');\n    this.div.style.position = 'absolute';\n    this.div.className = 'rect-circle';\n    this.div.style.transform = 'scale(0.8)';\n    setTimeout(() => {\n      this.div.style.width = `${width}px`;\n      this.div.style.height = `${height}px`;\n      this.div.style.transform = 'scale(1)';\n    }, 1000);\n    // this.div.textContent = 'mass: ' + this.mass;\n    // this.div.style.backgroundColor = 'rgba(0, 0, 255, 0.5)'; // Semi-transparent blue\n    // this.div.style.border = '1px solid black';\n    document.body.appendChild(this.div);\n  }\n\n  update() {\n    // Update the position and rotation of the div\n    this.div.style.left = `${this.mCenter.x - this.mWidth / 2}px`;\n    this.div.style.top = `${this.mCenter.y - this.mHeight / 2}px`;\n    this.div.style.transform = `rotate(${this.mAngle}rad)`;\n  }\n\n  move(v) {\n    super.move(v);\n    this.mVertex = this.mVertex.map((vertex) => vertex.add(v));\n    this.update(); // Update div position after moving\n  }\n  \n\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map((vertex) => vertex.rotate(this.mCenter, angle));\n    this.update(); // Update div rotation after rotating\n  }\n\n  collisionTest(otherShape, collisionInfo) {\n    let status = false;\n    if (otherShape.mType === 'Circle') {\n      status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n      status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n  }\n\n  findSupportPoint(dir, ptOnEdge) {\n    let tmpSupport = {\n      mSupportPoint: null,\n      mSupportPointDist: -9999999,\n    };\n\n    let vToEdge;\n    let projection;\n\n    for (let i = 0; i < this.mVertex.length; i++) {\n      vToEdge = this.mVertex[i].subtract(ptOnEdge);\n      projection = vToEdge.dot(dir);\n\n      if (projection > 0 && projection > tmpSupport.mSupportPointDist) {\n        tmpSupport.mSupportPoint = this.mVertex[i];\n        tmpSupport.mSupportPointDist = projection;\n      }\n    }\n\n    return tmpSupport;\n  }\n\n  findAxisLeastPenetration(otherRect, collisionInfo) {\n    let n;\n    let supportPoint = null;\n    let bestDistance = Infinity;\n    let bestIndex = null;\n    let hasSupport = true;\n    let i = 0;\n\n    while (hasSupport && i < this.mFaceNormal.length) {\n      n = this.mFaceNormal[i];\n\n      const dir = n.scale(-1);\n      const ptOnEdge = this.mVertex[i];\n\n      const tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n      hasSupport = tmpSupport && tmpSupport.mSupportPoint !== null;\n\n      if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n        bestDistance = tmpSupport.mSupportPointDist;\n        bestIndex = i;\n        supportPoint = tmpSupport.mSupportPoint;\n      }\n      i++;\n    }\n\n    if (hasSupport && bestIndex !== null && supportPoint !== null) {\n      const bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n      collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n    }\n\n    return hasSupport;\n  }\n\n  collidedRectRect(r1, r2, collisionInfo) {\n    let status1 = false;\n    let status2 = false;\n    const collisionInfoR1 = new CollisionInfo();\n    const collisionInfoR2 = new CollisionInfo();\n\n    status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n    if (status1) {\n      status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n      if (status2) {\n        if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n          const depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n          collisionInfo.setInfo(\n            collisionInfoR1.getDepth(),\n            collisionInfoR1.getNormal(),\n            collisionInfoR1.mStart.subtract(depthVec)\n          );\n        } else {\n          collisionInfo.setInfo(\n            collisionInfoR2.getDepth(),\n            collisionInfoR2.getNormal().scale(-1),\n            collisionInfoR2.mStart\n          );\n        }\n      }\n    }\n    return status1 && status2;\n  }\n\n  collidedRectCirc(otherCir, collisionInfo) {\n    let circ2Pos,\n      v,\n      projection,\n      bestDistance,\n      nearestEdge,\n      inside;\n\n    for (let i = 0; i < 4; ++i) {\n      circ2Pos = otherCir.mCenter;\n      v = circ2Pos.subtract(this.mVertex[i]);\n      projection = v.dot(this.mFaceNormal[i]);\n\n      if (projection > 0) {\n        bestDistance = projection;\n        nearestEdge = i;\n        inside = false;\n        break;\n      }\n\n      if (projection > bestDistance) {\n        bestDistance = projection;\n        nearestEdge = i;\n      }\n    }\n\n    if (!inside) {\n      let v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n      let v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n      let dot = v1.dot(v2);\n\n      if (dot < 0) {\n        const dis = v1.length();\n        if (dis > otherCir.mRadius) return false;\n\n        const normal = v1.normalize();\n        const radiusVec = normal.scale(-otherCir.mRadius);\n        collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n      } else {\n        v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n        v2 = v2.scale(-1);\n        dot = v1.dot(v2);\n\n        if (dot < 0) {\n          const dis = v1.length();\n          if (dis > otherCir.mRadius) return false;\n\n          const normal = v1.normalize();\n          const radiusVec = normal.scale(-otherCir.mRadius);\n          collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n        } else {\n          if (bestDistance < otherCir.mRadius) {\n            const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n            collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n          } else {\n            return false;\n          }\n        }\n      }\n    } else {\n      const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n      collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n    }\n\n    return true;\n  }\n}\n\nexport default Rectangle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}