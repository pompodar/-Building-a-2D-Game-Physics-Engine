{"ast":null,"code":"import RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nimport CollisionInfo from './CollisionInfo';\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, mass, friction, restitution, gravity = 0) {\n    super(center, /* mass */mass, /* friction */0.8, /* restitution */0.2, /* gravity*/gravity); // Pass all required params\n    this.mType = 'Rectangle';\n    this.gravity = gravity;\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n    console.log(this.gravity);\n\n    // Initialize vertices\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n\n    // Create and style the div\n    this.div = document.createElement('div');\n    this.div.style.position = 'absolute';\n    this.div.style.width = `${width}px`;\n    this.div.style.height = `${height}px`;\n    this.div.style.backgroundColor = 'rgba(0, 0, 255, 0.5)'; // Semi-transparent blue\n    this.div.style.border = '1px solid black';\n    document.body.appendChild(this.div);\n  }\n  update() {\n    // Example time step (dt) in seconds, assuming 60 FPS\n    const dt = 1 / 60;\n\n    // Apply gravity to vertical velocity (gravity is applied only if mass is non-zero)\n    if (this.gravity !== 0) {\n      this.mVelocity = this.mVelocity.add(this.mAcceleration.scale(dt));\n    }\n\n    // Update position based on velocity\n    this.mCenter = this.mCenter.add(this.mVelocity.scale(dt));\n\n    // Update rotation based on angular velocity\n    this.mAngularVelocity += this.mAngularAcceleration * dt;\n    //this.rotate(this.mAngularVelocity * dt);\n\n    // Update the position and rotation of the div\n    this.div.style.left = `${this.mCenter.x - this.width / 2}px`;\n    this.div.style.top = `${this.mCenter.y - this.height / 2}px`;\n    //this.div.style.transform = `rotate(${this.mAngle}rad)`;\n  }\n  move(v) {\n    super.move(v);\n    this.mVertex = this.mVertex.map(vertex => vertex.add(v));\n    this.update(); // Update div position after moving\n  }\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map(vertex => vertex.rotate(this.mCenter, angle));\n    this.update(); // Update div rotation after rotating\n  }\n  collisionTest(otherShape, collisionInfo) {\n    let status = false;\n    if (otherShape.mType === 'Circle') {\n      status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n      status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n  }\n  findSupportPoint(dir, ptOnEdge) {\n    let tmpSupport = {\n      mSupportPoint: null,\n      mSupportPointDist: -9999999\n    };\n    let vToEdge;\n    let projection;\n    for (let i = 0; i < this.mVertex.length; i++) {\n      vToEdge = this.mVertex[i].subtract(ptOnEdge);\n      projection = vToEdge.dot(dir);\n      if (projection > 0 && projection > tmpSupport.mSupportPointDist) {\n        tmpSupport.mSupportPoint = this.mVertex[i];\n        tmpSupport.mSupportPointDist = projection;\n      }\n    }\n    return tmpSupport;\n  }\n  findAxisLeastPenetration(otherRect, collisionInfo) {\n    let n;\n    let supportPoint = null;\n    let bestDistance = Infinity;\n    let bestIndex = null;\n    let hasSupport = true;\n    let i = 0;\n    while (hasSupport && i < this.mFaceNormal.length) {\n      n = this.mFaceNormal[i];\n      const dir = n.scale(-1);\n      const ptOnEdge = this.mVertex[i];\n      const tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n      hasSupport = tmpSupport && tmpSupport.mSupportPoint !== null;\n      if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n        bestDistance = tmpSupport.mSupportPointDist;\n        bestIndex = i;\n        supportPoint = tmpSupport.mSupportPoint;\n      }\n      i++;\n    }\n    if (hasSupport && bestIndex !== null && supportPoint !== null) {\n      const bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n      collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n    }\n    return hasSupport;\n  }\n  collidedRectRect(r1, r2, collisionInfo) {\n    let status1 = false;\n    let status2 = false;\n    const collisionInfoR1 = new CollisionInfo();\n    const collisionInfoR2 = new CollisionInfo();\n    status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n    if (status1) {\n      status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n      if (status2) {\n        if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n          const depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n          collisionInfo.setInfo(collisionInfoR1.getDepth(), collisionInfoR1.getNormal(), collisionInfoR1.mStart.subtract(depthVec));\n        } else {\n          collisionInfo.setInfo(collisionInfoR2.getDepth(), collisionInfoR2.getNormal().scale(-1), collisionInfoR2.mStart);\n        }\n      }\n    }\n    return status1 && status2;\n  }\n  collidedRectCirc(otherCir, collisionInfo) {\n    let circ2Pos, v, projection, bestDistance, nearestEdge, inside;\n    for (let i = 0; i < 4; ++i) {\n      circ2Pos = otherCir.mCenter;\n      v = circ2Pos.subtract(this.mVertex[i]);\n      projection = v.dot(this.mFaceNormal[i]);\n      if (projection > 0) {\n        bestDistance = projection;\n        nearestEdge = i;\n        inside = false;\n        break;\n      }\n      if (projection > bestDistance) {\n        bestDistance = projection;\n        nearestEdge = i;\n      }\n    }\n    if (!inside) {\n      let v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n      let v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n      let dot = v1.dot(v2);\n      if (dot < 0) {\n        const dis = v1.length();\n        if (dis > otherCir.mRadius) return false;\n        const normal = v1.normalize();\n        const radiusVec = normal.scale(-otherCir.mRadius);\n        collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n      } else {\n        v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n        v2 = v2.scale(-1);\n        dot = v1.dot(v2);\n        if (dot < 0) {\n          const dis = v1.length();\n          if (dis > otherCir.mRadius) return false;\n          const normal = v1.normalize();\n          const radiusVec = normal.scale(-otherCir.mRadius);\n          collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n        } else {\n          if (bestDistance < otherCir.mRadius) {\n            const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n            collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n          } else {\n            return false;\n          }\n        }\n      }\n    } else {\n      const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n      collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n    }\n    return true;\n  }\n}\nexport default Rectangle;","map":{"version":3,"names":["RigidShape","Vec2","CollisionInfo","Rectangle","constructor","center","width","height","mass","friction","restitution","gravity","mType","mWidth","mHeight","mVertex","mBoundRadius","Math","sqrt","console","log","x","y","div","document","createElement","style","position","backgroundColor","border","body","appendChild","update","dt","mVelocity","add","mAcceleration","scale","mCenter","mAngularVelocity","mAngularAcceleration","left","top","move","v","map","vertex","rotate","angle","collisionTest","otherShape","collisionInfo","status","collidedRectCirc","collidedRectRect","findSupportPoint","dir","ptOnEdge","tmpSupport","mSupportPoint","mSupportPointDist","vToEdge","projection","i","length","subtract","dot","findAxisLeastPenetration","otherRect","n","supportPoint","bestDistance","Infinity","bestIndex","hasSupport","mFaceNormal","bestVec","setInfo","r1","r2","status1","status2","collisionInfoR1","collisionInfoR2","getDepth","depthVec","getNormal","mStart","otherCir","circ2Pos","nearestEdge","inside","v1","v2","dis","mRadius","normal","normalize","radiusVec"],"sources":["/Users/mac/Desktop/apps/physics/physics_engine/React/src/Rectangle.js"],"sourcesContent":["import RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nimport CollisionInfo from './CollisionInfo';\n\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, mass, friction, restitution, gravity = 0) {\n    super(center, /* mass */ mass, /* friction */ 0.8, /* restitution */ 0.2, /* gravity*/ gravity); // Pass all required params\n    this.mType = 'Rectangle';\n    this.gravity = gravity;\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n\n    console.log(this.gravity);\n    \n  \n    // Initialize vertices\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n  \n    // Create and style the div\n    this.div = document.createElement('div');\n    this.div.style.position = 'absolute';\n    this.div.style.width = `${width}px`;\n    this.div.style.height = `${height}px`;\n    this.div.style.backgroundColor = 'rgba(0, 0, 255, 0.5)'; // Semi-transparent blue\n    this.div.style.border = '1px solid black';\n    document.body.appendChild(this.div);\n  }\n  \n\n  update() {\n    // Example time step (dt) in seconds, assuming 60 FPS\n    const dt = 1 / 60; \n  \n    // Apply gravity to vertical velocity (gravity is applied only if mass is non-zero)\n    if (this.gravity !== 0) {\n      this.mVelocity = this.mVelocity.add(this.mAcceleration.scale(dt));\n    }\n  \n    // Update position based on velocity\n    this.mCenter = this.mCenter.add(this.mVelocity.scale(dt));\n  \n    // Update rotation based on angular velocity\n    this.mAngularVelocity += this.mAngularAcceleration * dt;\n    //this.rotate(this.mAngularVelocity * dt);\n  \n    // Update the position and rotation of the div\n    this.div.style.left = `${this.mCenter.x - this.width / 2}px`;\n    this.div.style.top = `${this.mCenter.y - this.height / 2}px`;\n    //this.div.style.transform = `rotate(${this.mAngle}rad)`;\n  }\n  \n\n  move(v) {\n    super.move(v);\n    this.mVertex = this.mVertex.map((vertex) => vertex.add(v));\n    this.update(); // Update div position after moving\n  }\n  \n\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map((vertex) => vertex.rotate(this.mCenter, angle));\n    this.update(); // Update div rotation after rotating\n  }\n\n  collisionTest(otherShape, collisionInfo) {\n    let status = false;\n    if (otherShape.mType === 'Circle') {\n      status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n      status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n  }\n\n  findSupportPoint(dir, ptOnEdge) {\n    let tmpSupport = {\n      mSupportPoint: null,\n      mSupportPointDist: -9999999,\n    };\n\n    let vToEdge;\n    let projection;\n\n    for (let i = 0; i < this.mVertex.length; i++) {\n      vToEdge = this.mVertex[i].subtract(ptOnEdge);\n      projection = vToEdge.dot(dir);\n\n      if (projection > 0 && projection > tmpSupport.mSupportPointDist) {\n        tmpSupport.mSupportPoint = this.mVertex[i];\n        tmpSupport.mSupportPointDist = projection;\n      }\n    }\n\n    return tmpSupport;\n  }\n\n  findAxisLeastPenetration(otherRect, collisionInfo) {\n    let n;\n    let supportPoint = null;\n    let bestDistance = Infinity;\n    let bestIndex = null;\n    let hasSupport = true;\n    let i = 0;\n\n    while (hasSupport && i < this.mFaceNormal.length) {\n      n = this.mFaceNormal[i];\n\n      const dir = n.scale(-1);\n      const ptOnEdge = this.mVertex[i];\n\n      const tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n      hasSupport = tmpSupport && tmpSupport.mSupportPoint !== null;\n\n      if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n        bestDistance = tmpSupport.mSupportPointDist;\n        bestIndex = i;\n        supportPoint = tmpSupport.mSupportPoint;\n      }\n      i++;\n    }\n\n    if (hasSupport && bestIndex !== null && supportPoint !== null) {\n      const bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n      collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n    }\n\n    return hasSupport;\n  }\n\n  collidedRectRect(r1, r2, collisionInfo) {\n    let status1 = false;\n    let status2 = false;\n    const collisionInfoR1 = new CollisionInfo();\n    const collisionInfoR2 = new CollisionInfo();\n\n    status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n    if (status1) {\n      status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n      if (status2) {\n        if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n          const depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n          collisionInfo.setInfo(\n            collisionInfoR1.getDepth(),\n            collisionInfoR1.getNormal(),\n            collisionInfoR1.mStart.subtract(depthVec)\n          );\n        } else {\n          collisionInfo.setInfo(\n            collisionInfoR2.getDepth(),\n            collisionInfoR2.getNormal().scale(-1),\n            collisionInfoR2.mStart\n          );\n        }\n      }\n    }\n    return status1 && status2;\n  }\n\n  collidedRectCirc(otherCir, collisionInfo) {\n    let circ2Pos,\n      v,\n      projection,\n      bestDistance,\n      nearestEdge,\n      inside;\n\n    for (let i = 0; i < 4; ++i) {\n      circ2Pos = otherCir.mCenter;\n      v = circ2Pos.subtract(this.mVertex[i]);\n      projection = v.dot(this.mFaceNormal[i]);\n\n      if (projection > 0) {\n        bestDistance = projection;\n        nearestEdge = i;\n        inside = false;\n        break;\n      }\n\n      if (projection > bestDistance) {\n        bestDistance = projection;\n        nearestEdge = i;\n      }\n    }\n\n    if (!inside) {\n      let v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n      let v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n      let dot = v1.dot(v2);\n\n      if (dot < 0) {\n        const dis = v1.length();\n        if (dis > otherCir.mRadius) return false;\n\n        const normal = v1.normalize();\n        const radiusVec = normal.scale(-otherCir.mRadius);\n        collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n      } else {\n        v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n        v2 = v2.scale(-1);\n        dot = v1.dot(v2);\n\n        if (dot < 0) {\n          const dis = v1.length();\n          if (dis > otherCir.mRadius) return false;\n\n          const normal = v1.normalize();\n          const radiusVec = normal.scale(-otherCir.mRadius);\n          collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n        } else {\n          if (bestDistance < otherCir.mRadius) {\n            const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n            collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n          } else {\n            return false;\n          }\n        }\n      }\n    } else {\n      const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n      collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n    }\n\n    return true;\n  }\n}\n\nexport default Rectangle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}