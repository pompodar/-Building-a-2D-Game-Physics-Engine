{"ast":null,"code":"// Rectangle.js\nimport RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, fix) {\n    super(center);\n    this.mType = 'Rectangle';\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n\n    //this.mFix = fix;\n\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n  }\n  draw(context) {\n    context.save();\n    context.translate(this.mCenter.x, this.mCenter.y);\n    context.rotate(this.mAngle);\n    context.strokeRect(-this.mWidth / 2, -this.mHeight / 2, this.mWidth, this.mHeight);\n    context.restore();\n  }\n  move(v) {\n    super.move(v);\n    this.mVertex = this.mVertex.map(vertex => vertex.add(v));\n  }\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map(vertex => vertex.rotate(this.mCenter, angle));\n  }\n  collisionTest(otherShape, collisionInfo) {\n    var status = false;\n    if (otherShape.mType === \"Circle\") {\n      status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n      status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n  }\n  findSupportPoint(dir, ptOnEdge) {\n    // Об'єкт для збереження результатів\n    var tmpSupport = {\n      mSupportPoint: null,\n      mSupportPointDist: -9999999\n    };\n    var vToEdge;\n    var projection;\n\n    // Перевірка кожної вершини іншого об'єкта\n    for (var i = 0; i < this.mVertex.length; i++) {\n      vToEdge = this.mVertex[i].subtract(ptOnEdge);\n      projection = vToEdge.dot(dir);\n\n      // Знаходження найдовшої дистанції з певним ребром\n      // Напрямок -n, тому дистанція повинна бути додатною\n      if (projection > 0 && projection > tmpSupport.mSupportPointDist) {\n        tmpSupport.mSupportPoint = this.mVertex[i];\n        tmpSupport.mSupportPointDist = projection;\n      }\n    }\n    return tmpSupport; // Повернення результату для подальшого використання\n  }\n  findAxisLeastPenetration(otherRect, collisionInfo) {\n    var n;\n    var supportPoint = null;\n    var bestDistance = Infinity;\n    var bestIndex = null;\n    var hasSupport = true;\n    var i = 0;\n\n    // Loop through all face normals\n    while (hasSupport && i < this.mFaceNormal.length) {\n      // Retrieve the face normal from this rectangle\n      n = this.mFaceNormal[i];\n\n      // Calculate the opposite direction and a point on the edge\n      var dir = n.scale(-1);\n      var ptOnEdge = this.mVertex[i];\n\n      // Find the support point on the other rectangle\n      var tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n      hasSupport = tmpSupport && tmpSupport.mSupportPoint !== null;\n\n      // Check if the support point has the shortest distance\n      if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n        bestDistance = tmpSupport.mSupportPointDist;\n        bestIndex = i;\n        supportPoint = tmpSupport.mSupportPoint;\n      }\n      i++;\n    }\n\n    // If support points exist for all directions, set the collision information\n    if (hasSupport && bestIndex !== null && supportPoint !== null) {\n      var bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n      collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n    }\n    return hasSupport;\n  }\n  collidedRectRect(r1, r2, collisionInfo) {\n    var status1 = false;\n    var status2 = false;\n    var collisionInfoR1 = new CollisionInfo();\n    var collisionInfoR2 = new CollisionInfo();\n\n    // Find Axis of Least Penetration for both rectangles\n    status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n    if (status1) {\n      status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n      if (status2) {\n        // Choose the shorter normal as the normal\n        if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n          var depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n          collisionInfo.setInfo(collisionInfoR1.getDepth(), collisionInfoR1.getNormal(), collisionInfoR1.mStart.subtract(depthVec));\n        } else {\n          collisionInfo.setInfo(collisionInfoR2.getDepth(), collisionInfoR2.getNormal().scale(-1), collisionInfoR2.mStart);\n        }\n      }\n    }\n    return status1 && status2;\n  }\n  collidedRectCirc(otherCir, collisionInfo) {\n    // Step A: Compute the nearest edge\n    for (i = 0; i < 4; ++i) {\n      // Find the nearest face for the center of the circle\n      circ2Pos = otherCir.mCenter;\n      v = circ2Pos.subtract(this.mVertex[i]);\n      projection = v.dot(this.mFaceNormal[i]);\n      if (projection > 0) {\n        // If the center of the circle is outside the rectangle\n        bestDistance = projection;\n        nearestEdge = i;\n        inside = false;\n        break;\n      }\n      if (projection > bestDistance) {\n        bestDistance = projection;\n        nearestEdge = i;\n      }\n    }\n    if (!inside) {\n      // The center of the circle is outside the rectangle\n      // Step B1: If the center is in Region R1\n      var v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n      var v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n      var dot = v1.dot(v2);\n      if (dot < 0) {\n        // Region R1\n        var dis = v1.length();\n        if (dis > otherCir.mRadius) return false;\n        var normal = v1.normalize();\n        var radiusVec = normal.scale(-otherCir.mRadius);\n        collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n      } else {\n        // Step B2: If the center is in Region B2\n        var v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n        var v2 = v2.scale(-1);\n        var dot = v1.dot(v2);\n        if (dot < 0) {\n          // Region R2\n          var dis = v1.length();\n          if (dis > otherCir.mRadius) return false;\n          var normal = v1.normalize();\n          var radiusVec = normal.scale(-otherCir.mRadius);\n          collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n        } else {\n          // Step B3: If the center is in Region B3\n          if (bestDistance < otherCir.mRadius) {\n            var radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n            collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n          } else {\n            return false;\n          }\n        }\n      }\n    } else {\n      // Step C: If the center is inside the rectangle\n      var radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n      collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n    }\n    return true;\n  }\n}\nexport default Rectangle;","map":{"version":3,"names":["RigidShape","Vec2","Rectangle","constructor","center","width","height","fix","mType","mWidth","mHeight","mVertex","mBoundRadius","Math","sqrt","x","y","draw","context","save","translate","mCenter","rotate","mAngle","strokeRect","restore","move","v","map","vertex","add","angle","collisionTest","otherShape","collisionInfo","status","collidedRectCirc","collidedRectRect","findSupportPoint","dir","ptOnEdge","tmpSupport","mSupportPoint","mSupportPointDist","vToEdge","projection","i","length","subtract","dot","findAxisLeastPenetration","otherRect","n","supportPoint","bestDistance","Infinity","bestIndex","hasSupport","mFaceNormal","scale","bestVec","setInfo","r1","r2","status1","status2","collisionInfoR1","CollisionInfo","collisionInfoR2","getDepth","depthVec","getNormal","mStart","otherCir","circ2Pos","nearestEdge","inside","v1","v2","dis","mRadius","normal","normalize","radiusVec"],"sources":["/Users/mac/Desktop/apps/physics/physics_engine/physics-engine/src/Rectangle.js"],"sourcesContent":["// Rectangle.js\nimport RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\n\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, fix) {\n    super(center);\n    this.mType = 'Rectangle';\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width*width + height*height)/2;\n\n    //this.mFix = fix;\n\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n  }\n\n  draw(context) {\n    context.save();\n    context.translate(this.mCenter.x, this.mCenter.y);\n    context.rotate(this.mAngle);\n    context.strokeRect(-this.mWidth / 2, -this.mHeight / 2, this.mWidth, this.mHeight);\n    context.restore();\n  }\n\n  move(v) {\n    super.move(v);    \n    this.mVertex = this.mVertex.map(vertex => vertex.add(v));\n  }\n\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map(vertex => vertex.rotate(this.mCenter, angle));\n  }\n\n  collisionTest (otherShape, collisionInfo) {\n    var status = false;\n    if (otherShape.mType === \"Circle\") {\n    status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n    status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n   };\n   \n   findSupportPoint (dir, ptOnEdge) {\n       // Об'єкт для збереження результатів\n       var tmpSupport = {\n           mSupportPoint: null,\n           mSupportPointDist: -9999999\n       };\n   \n       var vToEdge;\n       var projection;\n   \n       // Перевірка кожної вершини іншого об'єкта\n       for (var i = 0; i < this.mVertex.length; i++) {\n           vToEdge = this.mVertex[i].subtract(ptOnEdge);\n           projection = vToEdge.dot(dir);\n   \n           // Знаходження найдовшої дистанції з певним ребром\n           // Напрямок -n, тому дистанція повинна бути додатною\n           if ((projection > 0) && (projection > tmpSupport.mSupportPointDist)) {\n               tmpSupport.mSupportPoint = this.mVertex[i];\n               tmpSupport.mSupportPointDist = projection;\n           }\n       }\n   \n       return tmpSupport; // Повернення результату для подальшого використання\n   };\n   \n   \n   findAxisLeastPenetration (otherRect, collisionInfo) {\n       var n;\n       var supportPoint = null;\n       var bestDistance = Infinity;\n       var bestIndex = null;\n       var hasSupport = true;\n       var i = 0;\n   \n       // Loop through all face normals\n       while (hasSupport && i < this.mFaceNormal.length) {\n           // Retrieve the face normal from this rectangle\n           n = this.mFaceNormal[i];\n   \n           // Calculate the opposite direction and a point on the edge\n           var dir = n.scale(-1);\n           var ptOnEdge = this.mVertex[i];\n   \n           // Find the support point on the other rectangle\n           var tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n           hasSupport = (tmpSupport && tmpSupport.mSupportPoint !== null);\n   \n           // Check if the support point has the shortest distance\n           if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n               bestDistance = tmpSupport.mSupportPointDist;\n               bestIndex = i;\n               supportPoint = tmpSupport.mSupportPoint;\n           }\n           i++;\n       }\n   \n       // If support points exist for all directions, set the collision information\n       if (hasSupport && bestIndex !== null && supportPoint !== null) {\n           var bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n           collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n       }\n   \n       return hasSupport;\n   };\n   \n   collidedRectRect (r1, r2, collisionInfo) {\n       var status1 = false;\n       var status2 = false;\n       var collisionInfoR1 = new CollisionInfo();\n       var collisionInfoR2 = new CollisionInfo();\n   \n       // Find Axis of Least Penetration for both rectangles\n       status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n       if (status1) {\n           status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n           if (status2) {\n               // Choose the shorter normal as the normal\n               if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n                   var depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n                   collisionInfo.setInfo(\n                       collisionInfoR1.getDepth(),\n                       collisionInfoR1.getNormal(),\n                       collisionInfoR1.mStart.subtract(depthVec)\n                   );\n               } else {\n                   collisionInfo.setInfo(\n                       collisionInfoR2.getDepth(),\n                       collisionInfoR2.getNormal().scale(-1),\n                       collisionInfoR2.mStart\n                   );\n               }\n           }\n       }\n       return status1 && status2;\n   };\n   \n   collidedRectCirc (otherCir, collisionInfo) {\n     // Step A: Compute the nearest edge\n     for (i = 0; i < 4; ++i) {\n       // Find the nearest face for the center of the circle\n       circ2Pos = otherCir.mCenter;\n       v = circ2Pos.subtract(this.mVertex[i]);\n       projection = v.dot(this.mFaceNormal[i]);\n       \n       if (projection > 0) {\n         // If the center of the circle is outside the rectangle\n         bestDistance = projection;\n         nearestEdge = i;\n         inside = false;\n         break;\n       }\n   \n       if (projection > bestDistance) {\n         bestDistance = projection;\n         nearestEdge = i;\n       }\n     }\n   \n     if (!inside) { // The center of the circle is outside the rectangle\n       // Step B1: If the center is in Region R1\n       var v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n       var v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n       var dot = v1.dot(v2);\n   \n       if (dot < 0) { // Region R1\n         var dis = v1.length();\n         if (dis > otherCir.mRadius) return false;\n   \n         var normal = v1.normalize();\n         var radiusVec = normal.scale(-otherCir.mRadius);\n         collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n   \n       } else { \n         // Step B2: If the center is in Region B2\n         var v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n         var v2 = v2.scale(-1);\n         var dot = v1.dot(v2);\n   \n         if (dot < 0) { // Region R2\n           var dis = v1.length();\n           if (dis > otherCir.mRadius) return false;\n   \n           var normal = v1.normalize();\n           var radiusVec = normal.scale(-otherCir.mRadius);\n           collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n   \n         } else { \n           // Step B3: If the center is in Region B3\n           if (bestDistance < otherCir.mRadius) {\n             var radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n             collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n           } else {\n             return false;\n           }\n         }\n       }\n     } else { \n       // Step C: If the center is inside the rectangle\n       var radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n       collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n     }\n   \n     return true;\n   };\n   \n}\n\nexport default Rectangle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}