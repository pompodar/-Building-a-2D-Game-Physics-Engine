{"ast":null,"code":"import RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nimport CollisionInfo from './CollisionInfo';\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, fix) {\n    super(center);\n    this.mType = 'Rectangle';\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n\n    // this.mFix = fix;\n\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n  }\n  draw(context) {\n    context.save();\n    context.translate(this.mCenter.x, this.mCenter.y);\n    context.rotate(this.mAngle);\n    context.strokeRect(-this.mWidth / 2, -this.mHeight / 2, this.mWidth, this.mHeight);\n    context.restore();\n  }\n  move(v) {\n    super.move(v);\n    this.mVertex = this.mVertex.map(vertex => vertex.add(v));\n  }\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map(vertex => vertex.rotate(this.mCenter, angle));\n  }\n  collisionTest(otherShape, collisionInfo) {\n    let status = false;\n    if (otherShape.mType === 'Circle') {\n      status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n      status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n  }\n  findSupportPoint(dir, ptOnEdge) {\n    // Об'єкт для збереження результатів\n    let tmpSupport = {\n      mSupportPoint: null,\n      mSupportPointDist: -9999999\n    };\n    let vToEdge;\n    let projection;\n\n    // Перевірка кожної вершини іншого об'єкта\n    for (let i = 0; i < this.mVertex.length; i++) {\n      vToEdge = this.mVertex[i].subtract(ptOnEdge);\n      projection = vToEdge.dot(dir);\n\n      // Знаходження найдовшої дистанції з певним ребром\n      // Напрямок -n, тому дистанція повинна бути додатною\n      if (projection > 0 && projection > tmpSupport.mSupportPointDist) {\n        tmpSupport.mSupportPoint = this.mVertex[i];\n        tmpSupport.mSupportPointDist = projection;\n      }\n    }\n    return tmpSupport; // Повернення результату для подальшого використання\n  }\n  findAxisLeastPenetration(otherRect, collisionInfo) {\n    let n;\n    let supportPoint = null;\n    let bestDistance = Infinity;\n    let bestIndex = null;\n    let hasSupport = true;\n    let i = 0;\n\n    // Loop through all face normals\n    while (hasSupport && i < this.mFaceNormal.length) {\n      // Retrieve the face normal from this rectangle\n      n = this.mFaceNormal[i];\n\n      // Calculate the opposite direction and a point on the edge\n      const dir = n.scale(-1);\n      const ptOnEdge = this.mVertex[i];\n\n      // Find the support point on the other rectangle\n      const tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n      hasSupport = tmpSupport && tmpSupport.mSupportPoint !== null;\n\n      // Check if the support point has the shortest distance\n      if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n        bestDistance = tmpSupport.mSupportPointDist;\n        bestIndex = i;\n        supportPoint = tmpSupport.mSupportPoint;\n      }\n      i++;\n    }\n\n    // If support points exist for all directions, set the collision information\n    if (hasSupport && bestIndex !== null && supportPoint !== null) {\n      const bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n      collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n    }\n    return hasSupport;\n  }\n  collidedRectRect(r1, r2, collisionInfo) {\n    let status1 = false;\n    let status2 = false;\n    const collisionInfoR1 = new CollisionInfo();\n    const collisionInfoR2 = new CollisionInfo();\n\n    // Find Axis of Least Penetration for both rectangles\n    status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n    if (status1) {\n      status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n      if (status2) {\n        // Choose the shorter normal as the normal\n        if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n          const depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n          collisionInfo.setInfo(collisionInfoR1.getDepth(), collisionInfoR1.getNormal(), collisionInfoR1.mStart.subtract(depthVec));\n        } else {\n          collisionInfo.setInfo(collisionInfoR2.getDepth(), collisionInfoR2.getNormal().scale(-1), collisionInfoR2.mStart);\n        }\n      }\n    }\n    return status1 && status2;\n  }\n  collidedRectCirc(otherCir, collisionInfo) {\n    let circ2Pos, v, projection, bestDistance, nearestEdge, inside;\n\n    // Step A: Compute the nearest edge\n    for (let i = 0; i < 4; ++i) {\n      // Find the nearest face for the center of the circle\n      circ2Pos = otherCir.mCenter;\n      v = circ2Pos.subtract(this.mVertex[i]);\n      projection = v.dot(this.mFaceNormal[i]);\n      if (projection > 0) {\n        // If the center of the circle is outside the rectangle\n        bestDistance = projection;\n        nearestEdge = i;\n        inside = false;\n        break;\n      }\n      if (projection > bestDistance) {\n        bestDistance = projection;\n        nearestEdge = i;\n      }\n    }\n    if (!inside) {\n      // The center of the circle is outside the rectangle\n      // Step B1: If the center is in Region R1\n      let v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n      let v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n      let dot = v1.dot(v2);\n      if (dot < 0) {\n        // Region R1\n        const dis = v1.length();\n        if (dis > otherCir.mRadius) return false;\n        const normal = v1.normalize();\n        const radiusVec = normal.scale(-otherCir.mRadius);\n        collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n      } else {\n        // Step B2: If the center is in Region B2\n        v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n        v2 = v2.scale(-1);\n        dot = v1.dot(v2);\n        if (dot < 0) {\n          // Region R2\n          const dis = v1.length();\n          if (dis > otherCir.mRadius) return false;\n          const normal = v1.normalize();\n          const radiusVec = normal.scale(-otherCir.mRadius);\n          collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n        } else {\n          // Step B3: If the center is in Region B3\n          if (bestDistance < otherCir.mRadius) {\n            const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n            collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n          } else {\n            return false;\n          }\n        }\n      }\n    } else {\n      // Step C: If the center is inside the rectangle\n      const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n      collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n    }\n    return true;\n  }\n}\nexport default Rectangle;","map":{"version":3,"names":["RigidShape","Vec2","CollisionInfo","Rectangle","constructor","center","width","height","fix","mType","mWidth","mHeight","mVertex","mBoundRadius","Math","sqrt","x","y","draw","context","save","translate","mCenter","rotate","mAngle","strokeRect","restore","move","v","map","vertex","add","angle","collisionTest","otherShape","collisionInfo","status","collidedRectCirc","collidedRectRect","findSupportPoint","dir","ptOnEdge","tmpSupport","mSupportPoint","mSupportPointDist","vToEdge","projection","i","length","subtract","dot","findAxisLeastPenetration","otherRect","n","supportPoint","bestDistance","Infinity","bestIndex","hasSupport","mFaceNormal","scale","bestVec","setInfo","r1","r2","status1","status2","collisionInfoR1","collisionInfoR2","getDepth","depthVec","getNormal","mStart","otherCir","circ2Pos","nearestEdge","inside","v1","v2","dis","mRadius","normal","normalize","radiusVec"],"sources":["/Users/mac/Desktop/apps/physics/physics_engine/physics-engine/src/Rectangle.js"],"sourcesContent":["import RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nimport CollisionInfo from './CollisionInfo';\n\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, fix) {\n    super(center);\n    this.mType = 'Rectangle';\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n\n    // this.mFix = fix;\n\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n  }\n\n  draw(context) {\n    context.save();\n    context.translate(this.mCenter.x, this.mCenter.y);\n    context.rotate(this.mAngle);\n    context.strokeRect(-this.mWidth / 2, -this.mHeight / 2, this.mWidth, this.mHeight);\n    context.restore();\n  }\n\n  move(v) {\n    super.move(v);\n    this.mVertex = this.mVertex.map((vertex) => vertex.add(v));\n  }\n\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map((vertex) => vertex.rotate(this.mCenter, angle));\n  }\n\n  collisionTest(otherShape, collisionInfo) {\n    let status = false;\n    if (otherShape.mType === 'Circle') {\n      status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n      status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n  }\n\n  findSupportPoint(dir, ptOnEdge) {\n    // Об'єкт для збереження результатів\n    let tmpSupport = {\n      mSupportPoint: null,\n      mSupportPointDist: -9999999,\n    };\n\n    let vToEdge;\n    let projection;\n\n    // Перевірка кожної вершини іншого об'єкта\n    for (let i = 0; i < this.mVertex.length; i++) {\n      vToEdge = this.mVertex[i].subtract(ptOnEdge);\n      projection = vToEdge.dot(dir);\n\n      // Знаходження найдовшої дистанції з певним ребром\n      // Напрямок -n, тому дистанція повинна бути додатною\n      if (projection > 0 && projection > tmpSupport.mSupportPointDist) {\n        tmpSupport.mSupportPoint = this.mVertex[i];\n        tmpSupport.mSupportPointDist = projection;\n      }\n    }\n\n    return tmpSupport; // Повернення результату для подальшого використання\n  }\n\n  findAxisLeastPenetration(otherRect, collisionInfo) {\n    let n;\n    let supportPoint = null;\n    let bestDistance = Infinity;\n    let bestIndex = null;\n    let hasSupport = true;\n    let i = 0;\n\n    // Loop through all face normals\n    while (hasSupport && i < this.mFaceNormal.length) {\n      // Retrieve the face normal from this rectangle\n      n = this.mFaceNormal[i];\n\n      // Calculate the opposite direction and a point on the edge\n      const dir = n.scale(-1);\n      const ptOnEdge = this.mVertex[i];\n\n      // Find the support point on the other rectangle\n      const tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n      hasSupport = tmpSupport && tmpSupport.mSupportPoint !== null;\n\n      // Check if the support point has the shortest distance\n      if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n        bestDistance = tmpSupport.mSupportPointDist;\n        bestIndex = i;\n        supportPoint = tmpSupport.mSupportPoint;\n      }\n      i++;\n    }\n\n    // If support points exist for all directions, set the collision information\n    if (hasSupport && bestIndex !== null && supportPoint !== null) {\n      const bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n      collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n    }\n\n    return hasSupport;\n  }\n\n  collidedRectRect(r1, r2, collisionInfo) {\n    let status1 = false;\n    let status2 = false;\n    const collisionInfoR1 = new CollisionInfo();\n    const collisionInfoR2 = new CollisionInfo();\n\n    // Find Axis of Least Penetration for both rectangles\n    status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n    if (status1) {\n      status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n      if (status2) {\n        // Choose the shorter normal as the normal\n        if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n          const depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n          collisionInfo.setInfo(\n            collisionInfoR1.getDepth(),\n            collisionInfoR1.getNormal(),\n            collisionInfoR1.mStart.subtract(depthVec)\n          );\n        } else {\n          collisionInfo.setInfo(\n            collisionInfoR2.getDepth(),\n            collisionInfoR2.getNormal().scale(-1),\n            collisionInfoR2.mStart\n          );\n        }\n      }\n    }\n    return status1 && status2;\n  }\n\n  collidedRectCirc(otherCir, collisionInfo) {\n    let circ2Pos,\n      v,\n      projection,\n      bestDistance,\n      nearestEdge,\n      inside;\n\n    // Step A: Compute the nearest edge\n    for (let i = 0; i < 4; ++i) {\n      // Find the nearest face for the center of the circle\n      circ2Pos = otherCir.mCenter;\n      v = circ2Pos.subtract(this.mVertex[i]);\n      projection = v.dot(this.mFaceNormal[i]);\n\n      if (projection > 0) {\n        // If the center of the circle is outside the rectangle\n        bestDistance = projection;\n        nearestEdge = i;\n        inside = false;\n        break;\n      }\n\n      if (projection > bestDistance) {\n        bestDistance = projection;\n        nearestEdge = i;\n      }\n    }\n\n    if (!inside) {\n      // The center of the circle is outside the rectangle\n      // Step B1: If the center is in Region R1\n      let v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n      let v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n      let dot = v1.dot(v2);\n\n      if (dot < 0) {\n        // Region R1\n        const dis = v1.length();\n        if (dis > otherCir.mRadius) return false;\n\n        const normal = v1.normalize();\n        const radiusVec = normal.scale(-otherCir.mRadius);\n        collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n      } else {\n        // Step B2: If the center is in Region B2\n        v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n        v2 = v2.scale(-1);\n        dot = v1.dot(v2);\n\n        if (dot < 0) {\n          // Region R2\n          const dis = v1.length();\n          if (dis > otherCir.mRadius) return false;\n\n          const normal = v1.normalize();\n          const radiusVec = normal.scale(-otherCir.mRadius);\n          collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n        } else {\n          // Step B3: If the center is in Region B3\n          if (bestDistance < otherCir.mRadius) {\n            const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n            collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n          } else {\n            return false;\n          }\n        }\n      }\n    } else {\n      // Step C: If the center is inside the rectangle\n      const radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n      collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n    }\n\n    return true;\n  }\n}\n\nexport default Rectangle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}