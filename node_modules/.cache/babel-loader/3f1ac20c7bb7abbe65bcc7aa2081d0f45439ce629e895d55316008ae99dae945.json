{"ast":null,"code":"import Vec2 from './Vec2';\nclass RigidShape {\n  constructor(center, mass, friction, restitution) {\n    this.updateInertia = function () {\n      // Expect this.mInvMass to be already inverted!\n      if (this.mInvMass === 0) this.mInertia = 0;else {\n        //inertia=mass*width^2+height^2\n        this.mInertia = 1 / this.mInvMass * (this.mWidth * this.mWidth + this.mHeight * this.mHeight) / 12;\n        this.mInertia = 1 / this.mInertia;\n      }\n    };\n    this.mCenter = center;\n    const width = 40;\n    const height = 40;\n    this.width = 40;\n    this.height = 40;\n    this.mAngle = 0;\n    this.mFix = 0;\n    this.mVelocity = new Vec2(0, 0);\n    this.mAcceleration = new Vec2(0, 10); // Gravity had to come in here - SV\n    //angle\n    this.mAngle = 0;\n    //negetive-- clockwise\n    //positive-- counterclockwise\n    this.mAngularVelocity = 0;\n    this.mAngularAcceleration = 0;\n    this.mVertex = [];\n    this.mFaceNormal = [];\n\n    // 0--TopLeft; 1--TopRight; 2--BottomRight; 3--BottomLeft\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n\n    // 0--Top;1--Right;2--Bottom;3--Left\n    // mFaceNormal is normal of face toward outside of rectangle\n    // SV - The face normal vectors will be used later for determining collisions.\n\n    this.mFaceNormal[0] = this.mVertex[1].subtract(this.mVertex[2]);\n    this.mFaceNormal[0] = this.mFaceNormal[0].normalize();\n    this.mFaceNormal[1] = this.mVertex[2].subtract(this.mVertex[3]);\n    this.mFaceNormal[1] = this.mFaceNormal[1].normalize();\n    this.mFaceNormal[2] = this.mVertex[3].subtract(this.mVertex[0]);\n    this.mFaceNormal[2] = this.mFaceNormal[2].normalize();\n    this.mFaceNormal[3] = this.mVertex[0].subtract(this.mVertex[1]);\n    this.mFaceNormal[3] = this.mFaceNormal[3].normalize();\n    this.mCenter = center;\n    this.mInertia = 0;\n    if (mass !== undefined) this.mInvMass = mass;else this.mInvMass = 1;\n    if (friction !== undefined) this.mFriction = friction;else this.mFriction = 0.8;\n    if (restitution !== undefined) this.mRestitution = restitution;else this.mRestitution = 0.2;\n    this.mVelocity = new Vec2(0, 0);\n    if (this.mInvMass !== 0) {\n      this.mInvMass = 1 / this.mInvMass;\n      this.mAcceleration = new Vec2(0, 10);\n    } else {\n      this.mAcceleration = new Vec2(0, 0);\n    }\n    //angle\n    this.mAngle = 0;\n    //negetive-- clockwise\n    //positive-- counterclockwise\n    this.mAngularVelocity = 0;\n    this.mAngularAcceleration = 0;\n    this.mBoundRadius = 0;\n    this.updateInertia();\n  }\n  update(canvasDimensions) {\n    // if (canvasDimensions && this.mCenter.y < canvasDimensions.height && this.mFix !== 0) {\n    //   //this.move(new Vec2(0, .1));\n    //   //this.rotate(.01);\n    // }\n    if (false) {\n      // mMovement comes in - SV\n      //var dt = gEngine.Core.mUpdateIntervalInSeconds;\n      const dt = 200;\n      //v += a*t\n      this.mVelocity = this.mVelocity.add(this.mAcceleration.scale(dt));\n      //s += v*t\n      this.move(this.mVelocity.scale(dt));\n      this.mAngularVelocity += this.mAngularAcceleration * dt;\n      this.rotate(this.mAngularVelocity * dt);\n    }\n  }\n  move(vec) {\n    this.mCenter = this.mCenter.add(vec);\n  }\n  rotate(angle) {\n    this.mAngle += angle;\n  }\n  boundTest(otherShape) {\n    var vFrom1to2 = otherShape.mCenter.subtract(this.mCenter);\n    var rSum = this.mBoundRadius + otherShape.mBoundRadius;\n    var dist = vFrom1to2.length();\n    if (dist > rSum) {\n      return false; //not overlapping\n    }\n    return true;\n  }\n  updateMass(delta) {\n    var mass;\n    if (this.mInvMass !== 0) mass = 1 / this.mInvMass;else mass = 0;\n    mass += delta;\n    if (mass <= 0) {\n      this.mInvMass = 0;\n      this.mVelocity = new Vec2(0, 0);\n      this.mAcceleration = new Vec2(0, 0);\n      this.mAngularVelocity = 0;\n      this.mAngularAcceleration = 0;\n    } else {\n      this.mInvMass = 1 / mass;\n      this.mAcceleration = new Vec2(0, 10);\n    }\n    this.updateInertia();\n  }\n}\nexport default RigidShape;","map":{"version":3,"names":["Vec2","RigidShape","constructor","center","mass","friction","restitution","updateInertia","mInvMass","mInertia","mWidth","mHeight","mCenter","width","height","mAngle","mFix","mVelocity","mAcceleration","mAngularVelocity","mAngularAcceleration","mVertex","mFaceNormal","x","y","subtract","normalize","undefined","mFriction","mRestitution","mBoundRadius","update","canvasDimensions","dt","add","scale","move","rotate","vec","angle","boundTest","otherShape","vFrom1to2","rSum","dist","length","updateMass","delta"],"sources":["/Users/mac/Desktop/apps/physics/physics_engine/physics-engine/src/RigidShape.js"],"sourcesContent":["import Vec2 from './Vec2';\n\nclass RigidShape {\n  constructor(center, mass, friction, restitution) {    \n    this.mCenter = center;\n    const width = 40;\n    const height = 40;\n    this.width = 40;\n    this.height = 40;\n    this.mAngle = 0;\n    this.mFix = 0;\n\n    this.mVelocity = new Vec2(0, 0);\n    this.mAcceleration = new Vec2(0, 10); // Gravity had to come in here - SV\n    //angle\n    this.mAngle = 0;\n    //negetive-- clockwise\n    //positive-- counterclockwise\n    this.mAngularVelocity = 0;\n    this.mAngularAcceleration = 0;\n\n    this.mVertex = [];\n    this.mFaceNormal = [];\n\n    // 0--TopLeft; 1--TopRight; 2--BottomRight; 3--BottomLeft\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n\n    // 0--Top;1--Right;2--Bottom;3--Left\n    // mFaceNormal is normal of face toward outside of rectangle\n    // SV - The face normal vectors will be used later for determining collisions.\n\n    this.mFaceNormal[0] = this.mVertex[1].subtract(this.mVertex[2]);\n    this.mFaceNormal[0] = this.mFaceNormal[0].normalize();\n    this.mFaceNormal[1] = this.mVertex[2].subtract(this.mVertex[3]);\n    this.mFaceNormal[1] = this.mFaceNormal[1].normalize();\n    this.mFaceNormal[2] = this.mVertex[3].subtract(this.mVertex[0]);\n    this.mFaceNormal[2] = this.mFaceNormal[2].normalize();\n    this.mFaceNormal[3] = this.mVertex[0].subtract(this.mVertex[1]);\n    this.mFaceNormal[3] = this.mFaceNormal[3].normalize();\n\n    this.mCenter = center;\n    this.mInertia = 0;\n    if (mass !== undefined)\n    this.mInvMass = mass;\n    else\n    this.mInvMass = 1;\n    if (friction !== undefined)\n    this.mFriction = friction;\n    else\n    this.mFriction = 0.8;\n    if (restitution !== undefined)\n    this.mRestitution = restitution;\n    else\n\n    this.mRestitution = 0.2;\n this.mVelocity = new Vec2(0, 0);\n if (this.mInvMass !== 0) {\n this.mInvMass = 1 / this.mInvMass;\n this.mAcceleration = new Vec2(0, 10);\n } else {\n this.mAcceleration = new Vec2(0, 0);\n }\n //angle\n this.mAngle = 0;\n //negetive-- clockwise\n //positive-- counterclockwise\n this.mAngularVelocity = 0;\n this.mAngularAcceleration = 0;\n this.mBoundRadius = 0;\n\n this.updateInertia();\n  }\n\n  update(canvasDimensions) {    \n    // if (canvasDimensions && this.mCenter.y < canvasDimensions.height && this.mFix !== 0) {\n    //   //this.move(new Vec2(0, .1));\n    //   //this.rotate(.01);\n    // }\n    if (false) { // mMovement comes in - SV\n      //var dt = gEngine.Core.mUpdateIntervalInSeconds;\n      const dt = 200;\n      //v += a*t\n      this.mVelocity = this.mVelocity.add(this.mAcceleration.scale(dt));\n      //s += v*t\n      this.move(this.mVelocity.scale(dt));\n      this.mAngularVelocity += this.mAngularAcceleration * dt;\n      this.rotate(this.mAngularVelocity * dt);\n      }\n  }\n\n  move(vec) {\n    this.mCenter = this.mCenter.add(vec);\n  }\n\n  rotate(angle) {\n    this.mAngle += angle;\n  }\n\n  boundTest (otherShape) {    \n    var vFrom1to2 = otherShape.mCenter.subtract(this.mCenter);\n    var rSum = this.mBoundRadius + otherShape.mBoundRadius;\n    var dist = vFrom1to2.length();\n\n    if (dist > rSum) {\n       return false; //not overlapping\n    }\n\n    \n    \n    return true;\n};\nupdateMass (delta) {\n  var mass;\n  if (this.mInvMass !== 0)\n  mass = 1 / this.mInvMass;\n  else\n  mass = 0;\n  mass += delta;\n  if (mass <= 0) {\n  this.mInvMass = 0;\n  this.mVelocity = new Vec2(0, 0);\n  this.mAcceleration = new Vec2(0, 0);\n  this.mAngularVelocity = 0;\n  this.mAngularAcceleration = 0;\n  } else {\n  this.mInvMass = 1 / mass;\n  this.mAcceleration = new Vec2(0, 10);\n  }\n  this.updateInertia();\n}\n\nupdateInertia = function () {\n      // Expect this.mInvMass to be already inverted!\n if (this.mInvMass === 0)\n  this.mInertia = 0;\n  else {\n  //inertia=mass*width^2+height^2\n  this.mInertia = (1 / this.mInvMass) * (this.mWidth *\n this.mWidth + this.mHeight * this.mHeight) / 12;\n  this.mInertia = 1 / this.mInertia;\n  }\n };\n}\n\nexport default RigidShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}