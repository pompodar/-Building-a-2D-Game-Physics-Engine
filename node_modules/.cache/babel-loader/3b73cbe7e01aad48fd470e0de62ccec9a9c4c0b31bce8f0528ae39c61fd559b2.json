{"ast":null,"code":"import Vec2 from './Vec2';\nclass RigidShape {\n  constructor(center, mass, friction, restitution) {\n    this.mCenter = center;\n    const width = 40;\n    const height = 40;\n    this.width = 40;\n    this.height = 40;\n    this.mAngle = 0;\n    this.mFix = 0;\n    this.mVelocity = new Vec2(0, 0);\n    this.mAcceleration = gEngine.Core.mGravity;\n    //angle\n    this.mAngle = 0;\n    //negetive-- clockwise\n    //positive-- counterclockwise\n    this.mAngularVelocity = 0;\n    this.mAngularAcceleration = 0;\n    this.mVertex = [];\n    this.mFaceNormal = [];\n\n    // 0--TopLeft; 1--TopRight; 2--BottomRight; 3--BottomLeft\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n\n    // 0--Top;1--Right;2--Bottom;3--Left\n    // mFaceNormal is normal of face toward outside of rectangle\n    // SV - The face normal vectors will be used later for determining collisions.\n\n    this.mFaceNormal[0] = this.mVertex[1].subtract(this.mVertex[2]);\n    this.mFaceNormal[0] = this.mFaceNormal[0].normalize();\n    this.mFaceNormal[1] = this.mVertex[2].subtract(this.mVertex[3]);\n    this.mFaceNormal[1] = this.mFaceNormal[1].normalize();\n    this.mFaceNormal[2] = this.mVertex[3].subtract(this.mVertex[0]);\n    this.mFaceNormal[2] = this.mFaceNormal[2].normalize();\n    this.mFaceNormal[3] = this.mVertex[0].subtract(this.mVertex[1]);\n    this.mFaceNormal[3] = this.mFaceNormal[3].normalize();\n  }\n  update(canvasDimensions) {\n    if (canvasDimensions && this.mCenter.y < canvasDimensions.height && this.mFix !== 0) {\n      //this.move(new Vec2(0, .1));\n      //this.rotate(.01);\n    }\n  }\n  move(vec) {\n    this.mCenter = this.mCenter.add(vec);\n  }\n  rotate(angle) {\n    this.mAngle += angle;\n  }\n  boundTest(otherShape) {\n    var vFrom1to2 = otherShape.mCenter.subtract(this.mCenter);\n    var rSum = this.mBoundRadius + otherShape.mBoundRadius;\n    var dist = vFrom1to2.length();\n    if (dist > rSum) {\n      return false; //not overlapping\n    }\n    return true;\n  }\n}\nexport default RigidShape;","map":{"version":3,"names":["Vec2","RigidShape","constructor","center","mass","friction","restitution","mCenter","width","height","mAngle","mFix","mVelocity","mAcceleration","gEngine","Core","mGravity","mAngularVelocity","mAngularAcceleration","mVertex","mFaceNormal","x","y","subtract","normalize","update","canvasDimensions","move","vec","add","rotate","angle","boundTest","otherShape","vFrom1to2","rSum","mBoundRadius","dist","length"],"sources":["/Users/mac/Desktop/apps/physics/physics_engine/physics-engine/src/RigidShape.js"],"sourcesContent":["import Vec2 from './Vec2';\n\nclass RigidShape {\n  constructor(center, mass, friction, restitution) {    \n    this.mCenter = center;\n    const width = 40;\n    const height = 40;\n    this.width = 40;\n    this.height = 40;\n    this.mAngle = 0;\n    this.mFix = 0;\n\n    this.mVelocity = new Vec2(0, 0);\n    this.mAcceleration = gEngine.Core.mGravity;\n    //angle\n    this.mAngle = 0;\n    //negetive-- clockwise\n    //positive-- counterclockwise\n    this.mAngularVelocity = 0;\n    this.mAngularAcceleration = 0;\n    \n    this.mVertex = [];\n    this.mFaceNormal = [];\n\n    // 0--TopLeft; 1--TopRight; 2--BottomRight; 3--BottomLeft\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n\n    // 0--Top;1--Right;2--Bottom;3--Left\n    // mFaceNormal is normal of face toward outside of rectangle\n    // SV - The face normal vectors will be used later for determining collisions.\n\n    this.mFaceNormal[0] = this.mVertex[1].subtract(this.mVertex[2]);\n    this.mFaceNormal[0] = this.mFaceNormal[0].normalize();\n    this.mFaceNormal[1] = this.mVertex[2].subtract(this.mVertex[3]);\n    this.mFaceNormal[1] = this.mFaceNormal[1].normalize();\n    this.mFaceNormal[2] = this.mVertex[3].subtract(this.mVertex[0]);\n    this.mFaceNormal[2] = this.mFaceNormal[2].normalize();\n    this.mFaceNormal[3] = this.mVertex[0].subtract(this.mVertex[1]);\n    this.mFaceNormal[3] = this.mFaceNormal[3].normalize();\n\n  }\n\n  update(canvasDimensions) {    \n    if (canvasDimensions && this.mCenter.y < canvasDimensions.height && this.mFix !== 0) {\n      //this.move(new Vec2(0, .1));\n      //this.rotate(.01);\n    }\n  }\n\n  move(vec) {\n    this.mCenter = this.mCenter.add(vec);\n  }\n\n  rotate(angle) {\n    this.mAngle += angle;\n  }\n\n  boundTest (otherShape) {    \n    var vFrom1to2 = otherShape.mCenter.subtract(this.mCenter);\n    var rSum = this.mBoundRadius + otherShape.mBoundRadius;\n    var dist = vFrom1to2.length();\n\n    if (dist > rSum) {\n       return false; //not overlapping\n    }\n    \n    return true;\n};\n}\n\nexport default RigidShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}