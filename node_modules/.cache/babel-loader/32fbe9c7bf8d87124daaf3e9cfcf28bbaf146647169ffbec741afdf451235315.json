{"ast":null,"code":"// Rectangle.js\nimport RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nimport CollisionInfo from './CollisionInfo';\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, fix) {\n    super(center);\n    this.mType = 'Rectangle';\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width * width + height * height) / 2;\n\n    //this.mFix = fix;\n\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n  }\n  draw(context) {\n    context.save();\n    context.translate(this.mCenter.x, this.mCenter.y);\n    context.rotate(this.mAngle);\n    context.strokeRect(-this.mWidth / 2, -this.mHeight / 2, this.mWidth, this.mHeight);\n    context.restore();\n  }\n  move(v) {\n    super.move(v);\n    this.mVertex = this.mVertex.map(vertex => vertex.add(v));\n  }\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map(vertex => vertex.rotate(this.mCenter, angle));\n  }\n  collisionTest(otherShape, collisionInfo) {\n    var status = false;\n    if (otherShape.mType === \"Circle\") {\n      status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n      status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n  }\n  findSupportPoint(dir, ptOnEdge) {\n    // Об'єкт для збереження результатів\n    var tmpSupport = {\n      mSupportPoint: null,\n      mSupportPointDist: -9999999\n    };\n    var vToEdge;\n    var projection;\n\n    // Перевірка кожної вершини іншого об'єкта\n    for (var i = 0; i < this.mVertex.length; i++) {\n      vToEdge = this.mVertex[i].subtract(ptOnEdge);\n      projection = vToEdge.dot(dir);\n\n      // Знаходження найдовшої дистанції з певним ребром\n      // Напрямок -n, тому дистанція повинна бути додатною\n      if (projection > 0 && projection > tmpSupport.mSupportPointDist) {\n        tmpSupport.mSupportPoint = this.mVertex[i];\n        tmpSupport.mSupportPointDist = projection;\n      }\n    }\n    return tmpSupport; // Повернення результату для подальшого використання\n  }\n  findAxisLeastPenetration(otherRect, collisionInfo) {\n    var n;\n    var supportPoint = null;\n    var bestDistance = Infinity;\n    var bestIndex = null;\n    var hasSupport = true;\n    var i = 0;\n    console.log(this.mFaceNormal, \"center\");\n\n    // Loop through all face normals\n    while (hasSupport && i < this.mFaceNormal.length) {\n      // Retrieve the face normal from this rectangle\n      n = this.mFaceNormal[i];\n\n      // Calculate the opposite direction and a point on the edge\n      var dir = n.scale(-1);\n      var ptOnEdge = this.mVertex[i];\n\n      // Find the support point on the other rectangle\n      var tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n      hasSupport = tmpSupport && tmpSupport.mSupportPoint !== null;\n\n      // Check if the support point has the shortest distance\n      if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n        bestDistance = tmpSupport.mSupportPointDist;\n        bestIndex = i;\n        supportPoint = tmpSupport.mSupportPoint;\n      }\n      i++;\n    }\n\n    // If support points exist for all directions, set the collision information\n    if (hasSupport && bestIndex !== null && supportPoint !== null) {\n      var bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n      collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n    }\n    console.log(hasSupport, \"hasSupport\");\n    return hasSupport;\n  }\n  collidedRectRect(r1, r2, collisionInfo) {\n    var status1 = false;\n    var status2 = false;\n    var collisionInfoR1 = new CollisionInfo();\n    var collisionInfoR2 = new CollisionInfo();\n\n    // Find Axis of Least Penetration for both rectangles\n    status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n    if (status1) {\n      status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n      if (status2) {\n        // Choose the shorter normal as the normal\n        if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n          var depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n          collisionInfo.setInfo(collisionInfoR1.getDepth(), collisionInfoR1.getNormal(), collisionInfoR1.mStart.subtract(depthVec));\n        } else {\n          collisionInfo.setInfo(collisionInfoR2.getDepth(), collisionInfoR2.getNormal().scale(-1), collisionInfoR2.mStart);\n        }\n      }\n    }\n    return status1 && status2;\n  }\n  collidedRectCirc(otherCir, collisionInfo) {\n    let circ2Pos, v, projection, bestDistance, nearestEdge, inside;\n\n    // Step A: Compute the nearest edge\n    for (let i = 0; i < 4; ++i) {\n      // Find the nearest face for the center of the circle\n      circ2Pos = otherCir.mCenter;\n      v = circ2Pos.subtract(this.mVertex[i]);\n      projection = v.dot(this.mFaceNormal[i]);\n      if (projection > 0) {\n        // If the center of the circle is outside the rectangle\n        bestDistance = projection;\n        nearestEdge = i;\n        inside = false;\n        break;\n      }\n      if (projection > bestDistance) {\n        bestDistance = projection;\n        nearestEdge = i;\n      }\n    }\n    if (!inside) {\n      // The center of the circle is outside the rectangle\n      // Step B1: If the center is in Region R1\n      var v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n      var v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n      var dot = v1.dot(v2);\n      if (dot < 0) {\n        // Region R1\n        var dis = v1.length();\n        if (dis > otherCir.mRadius) return false;\n        var normal = v1.normalize();\n        var radiusVec = normal.scale(-otherCir.mRadius);\n        collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n      } else {\n        // Step B2: If the center is in Region B2\n        var v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n        var v2 = v2.scale(-1);\n        var dot = v1.dot(v2);\n        if (dot < 0) {\n          // Region R2\n          var dis = v1.length();\n          if (dis > otherCir.mRadius) return false;\n          var normal = v1.normalize();\n          var radiusVec = normal.scale(-otherCir.mRadius);\n          collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n        } else {\n          // Step B3: If the center is in Region B3\n          if (bestDistance < otherCir.mRadius) {\n            var radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n            collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n          } else {\n            return false;\n          }\n        }\n      }\n    } else {\n      // Step C: If the center is inside the rectangle\n      var radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n      collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n    }\n    return true;\n  }\n}\nexport default Rectangle;","map":{"version":3,"names":["RigidShape","Vec2","CollisionInfo","Rectangle","constructor","center","width","height","fix","mType","mWidth","mHeight","mVertex","mBoundRadius","Math","sqrt","x","y","draw","context","save","translate","mCenter","rotate","mAngle","strokeRect","restore","move","v","map","vertex","add","angle","collisionTest","otherShape","collisionInfo","status","collidedRectCirc","collidedRectRect","findSupportPoint","dir","ptOnEdge","tmpSupport","mSupportPoint","mSupportPointDist","vToEdge","projection","i","length","subtract","dot","findAxisLeastPenetration","otherRect","n","supportPoint","bestDistance","Infinity","bestIndex","hasSupport","console","log","mFaceNormal","scale","bestVec","setInfo","r1","r2","status1","status2","collisionInfoR1","collisionInfoR2","getDepth","depthVec","getNormal","mStart","otherCir","circ2Pos","nearestEdge","inside","v1","v2","dis","mRadius","normal","normalize","radiusVec"],"sources":["/Users/mac/Desktop/apps/physics/physics_engine/physics-engine/src/Rectangle.js"],"sourcesContent":["// Rectangle.js\nimport RigidShape from './RigidShape';\nimport Vec2 from './Vec2';\nimport CollisionInfo from './CollisionInfo';\n\nclass Rectangle extends RigidShape {\n  constructor(center, width, height, fix) {\n    super(center);\n    this.mType = 'Rectangle';\n    this.mWidth = width;\n    this.mHeight = height;\n    this.mVertex = [];\n    this.mBoundRadius = Math.sqrt(width*width + height*height)/2;\n\n    //this.mFix = fix;\n\n    this.mVertex[0] = new Vec2(center.x - width / 2, center.y - height / 2);\n    this.mVertex[1] = new Vec2(center.x + width / 2, center.y - height / 2);\n    this.mVertex[2] = new Vec2(center.x + width / 2, center.y + height / 2);\n    this.mVertex[3] = new Vec2(center.x - width / 2, center.y + height / 2);\n  }\n\n  draw(context) {\n    context.save();\n    context.translate(this.mCenter.x, this.mCenter.y);\n    context.rotate(this.mAngle);\n    context.strokeRect(-this.mWidth / 2, -this.mHeight / 2, this.mWidth, this.mHeight);\n    context.restore();\n  }\n\n  move(v) {\n    super.move(v);    \n    this.mVertex = this.mVertex.map(vertex => vertex.add(v));\n  }\n\n  rotate(angle) {\n    super.rotate(angle);\n    this.mVertex = this.mVertex.map(vertex => vertex.rotate(this.mCenter, angle));\n  }\n\n  collisionTest (otherShape, collisionInfo) {    \n    var status = false;\n    if (otherShape.mType === \"Circle\") {\n    status = this.collidedRectCirc(otherShape, collisionInfo);\n    } else {\n    status = this.collidedRectRect(this, otherShape, collisionInfo);\n    }\n    return status;\n   };\n   \n   findSupportPoint (dir, ptOnEdge) {\n       // Об'єкт для збереження результатів\n       var tmpSupport = {\n           mSupportPoint: null,\n           mSupportPointDist: -9999999\n       };\n   \n       var vToEdge;\n       var projection;\n   \n       // Перевірка кожної вершини іншого об'єкта\n       for (var i = 0; i < this.mVertex.length; i++) {\n           vToEdge = this.mVertex[i].subtract(ptOnEdge);\n           projection = vToEdge.dot(dir);\n   \n           // Знаходження найдовшої дистанції з певним ребром\n           // Напрямок -n, тому дистанція повинна бути додатною\n           if ((projection > 0) && (projection > tmpSupport.mSupportPointDist)) {\n               tmpSupport.mSupportPoint = this.mVertex[i];\n               tmpSupport.mSupportPointDist = projection;\n           }\n       }\n   \n       return tmpSupport; // Повернення результату для подальшого використання\n   };\n   \n   \n   findAxisLeastPenetration (otherRect, collisionInfo) {\n       var n;\n       var supportPoint = null;\n       var bestDistance = Infinity;\n       var bestIndex = null;\n       var hasSupport = true;\n       var i = 0;              \n\n       console.log(this.mFaceNormal, \"center\")       \n   \n       // Loop through all face normals\n       while (hasSupport && i < this.mFaceNormal.length) {\n           // Retrieve the face normal from this rectangle\n           n = this.mFaceNormal[i];\n   \n           // Calculate the opposite direction and a point on the edge\n           var dir = n.scale(-1);\n           var ptOnEdge = this.mVertex[i];\n   \n           // Find the support point on the other rectangle\n           var tmpSupport = otherRect.findSupportPoint(dir, ptOnEdge);\n           hasSupport = (tmpSupport && tmpSupport.mSupportPoint !== null);\n   \n           // Check if the support point has the shortest distance\n           if (hasSupport && tmpSupport.mSupportPointDist < bestDistance) {\n               bestDistance = tmpSupport.mSupportPointDist;\n               bestIndex = i;\n               supportPoint = tmpSupport.mSupportPoint;\n           }\n           i++;\n       }\n   \n       // If support points exist for all directions, set the collision information\n       if (hasSupport && bestIndex !== null && supportPoint !== null) {\n           var bestVec = this.mFaceNormal[bestIndex].scale(bestDistance);\n           collisionInfo.setInfo(bestDistance, this.mFaceNormal[bestIndex], supportPoint.add(bestVec));\n       }\n   \n       console.log(hasSupport, \"hasSupport\")\n\n       return hasSupport;\n   };\n   \n   collidedRectRect (r1, r2, collisionInfo) {\n       var status1 = false;\n       var status2 = false;\n       var collisionInfoR1 = new CollisionInfo();\n       var collisionInfoR2 = new CollisionInfo();\n   \n       // Find Axis of Least Penetration for both rectangles\n       status1 = r1.findAxisLeastPenetration(r2, collisionInfoR1);\n       if (status1) {\n           status2 = r2.findAxisLeastPenetration(r1, collisionInfoR2);\n           if (status2) {\n               // Choose the shorter normal as the normal\n               if (collisionInfoR1.getDepth() < collisionInfoR2.getDepth()) {\n                   var depthVec = collisionInfoR1.getNormal().scale(collisionInfoR1.getDepth());\n                   collisionInfo.setInfo(\n                       collisionInfoR1.getDepth(),\n                       collisionInfoR1.getNormal(),\n                       collisionInfoR1.mStart.subtract(depthVec)\n                   );\n               } else {\n                   collisionInfo.setInfo(\n                       collisionInfoR2.getDepth(),\n                       collisionInfoR2.getNormal().scale(-1),\n                       collisionInfoR2.mStart\n                   );\n               }               \n           }\n       }\n       return status1 && status2;\n   };\n\n   collidedRectCirc (otherCir, collisionInfo) {\n    let circ2Pos, v, projection, bestDistance, nearestEdge, inside;\n\n     // Step A: Compute the nearest edge\n     for (let i = 0; i < 4; ++i) {\n       // Find the nearest face for the center of the circle\n       circ2Pos = otherCir.mCenter;\n       v = circ2Pos.subtract(this.mVertex[i]);\n       projection = v.dot(this.mFaceNormal[i]);\n       \n       if (projection > 0) {\n         // If the center of the circle is outside the rectangle\n         bestDistance = projection;\n         nearestEdge = i;\n         inside = false;\n         break;\n       }\n   \n       if (projection > bestDistance) {\n         bestDistance = projection;\n         nearestEdge = i;\n       }\n     }\n   \n     if (!inside) { // The center of the circle is outside the rectangle\n       // Step B1: If the center is in Region R1\n       var v1 = circ2Pos.subtract(this.mVertex[nearestEdge]);\n       var v2 = this.mVertex[(nearestEdge + 1) % 4].subtract(this.mVertex[nearestEdge]);\n       var dot = v1.dot(v2);\n   \n       if (dot < 0) { // Region R1\n         var dis = v1.length();\n         if (dis > otherCir.mRadius) return false;\n   \n         var normal = v1.normalize();\n         var radiusVec = normal.scale(-otherCir.mRadius);\n         collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n   \n       } else { \n         // Step B2: If the center is in Region B2\n         var v1 = circ2Pos.subtract(this.mVertex[(nearestEdge + 1) % 4]);\n         var v2 = v2.scale(-1);\n         var dot = v1.dot(v2);\n   \n         if (dot < 0) { // Region R2\n           var dis = v1.length();\n           if (dis > otherCir.mRadius) return false;\n   \n           var normal = v1.normalize();\n           var radiusVec = normal.scale(-otherCir.mRadius);\n           collisionInfo.setInfo(otherCir.mRadius - dis, normal, circ2Pos.add(radiusVec));\n   \n         } else { \n           // Step B3: If the center is in Region B3\n           if (bestDistance < otherCir.mRadius) {\n             var radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n             collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n           } else {\n             return false;\n           }\n         }\n       }\n     } else { \n       // Step C: If the center is inside the rectangle\n       var radiusVec = this.mFaceNormal[nearestEdge].scale(otherCir.mRadius);\n       collisionInfo.setInfo(otherCir.mRadius - bestDistance, this.mFaceNormal[nearestEdge], circ2Pos.subtract(radiusVec));\n     }\n   \n     return true;\n   };\n   \n}\n\nexport default Rectangle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}